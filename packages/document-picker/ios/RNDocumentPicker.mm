// LICENSE: see License.md in the package root


#import "RNDocumentPicker.h"

#import "RCTConvert+RNDocumentPicker.h"
// this header file is generated by Xcode: https://developer.apple.com/documentation/swift/importing-swift-into-objective-c
// if it cannot be found, try cleaning the build folder and Xcode derived data folder

// When using use_frameworks! :linkage => :static in Podfile
#if __has_include(<react_native_document_picker/react_native_document_picker-Swift.h>)
#import <react_native_document_picker/react_native_document_picker-Swift.h>
#else
#import "react_native_document_picker-Swift.h"
#endif

@interface RNDocumentPicker ()
@end

@implementation RNDocumentPicker {
  DocPicker *_docPicker;
  DocSaver *_docSaver;
}

// initialization happens on serial queue so there are no races
- (DocPicker *)docPicker {
  if (!_docPicker) {
    _docPicker = [DocPicker new];
  }
  return _docPicker;
}

- (DocSaver *)docSaver {
  if (!_docSaver) {
    _docSaver = [DocSaver new];
  }
  return _docSaver;
}

RCT_EXPORT_MODULE()

RCT_EXPORT_METHOD(pick:
                  (NSDictionary *) options
                  resolve:
                  (RCTPromiseResolveBlock) resolve
                  reject:
                  (RCTPromiseRejectBlock) reject)
{
  dispatch_async(dispatch_get_main_queue(), ^{
    [self.docPicker presentWithOptionsDict:options resolve:resolve reject:reject];
  });
}

RCT_EXPORT_METHOD(pickDirectory:(NSDictionary *)options resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject) {
  void (^resolveWithDirectoryUri)(NSArray<NSDictionary *> *) = ^void(NSArray<NSDictionary *> *pickedValues) {
    NSDictionary* firstObject = pickedValues.firstObject;
    resolve(firstObject);
  };
  
  [self pick:options resolve:resolveWithDirectoryUri reject:reject];
}

RCT_EXPORT_METHOD(keepLocalCopy:
                  (NSDictionary *) options
                  resolve:
                  (RCTPromiseResolveBlock) resolve
                  reject:
                  (RCTPromiseRejectBlock) reject) {
  NSArray *uris = options[@"files"];
  NSString *destination = options[@"destination"];
  
  [[FileOperations class] keepLocalCopyAtUniqueDestinationFrom:uris destinationPreset:destination resolve:resolve];
}

RCT_EXPORT_SYNCHRONOUS_TYPED_METHOD(NSDictionary *, isKnownType:(NSString *)kind value:(NSString *)value) {
  NSDictionary* result = [[IsKnownTypeImpl class] checkType:kind value:value];
  return result;
}

RCT_EXPORT_METHOD(writeDocuments:(NSDictionary *)options resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject) {
  dispatch_async(dispatch_get_main_queue(), ^{
    [self.docSaver presentWithOptionsDict:options resolve:resolve reject:reject];
  });
}

RCT_EXPORT_METHOD(releaseSecureAccess:(NSArray *)uris resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject) {
  [self.docPicker stopAccessingOpenedUrls:uris];
  resolve([NSNull null]);
}

RCT_EXPORT_METHOD(releaseLongTermAccess:(NSArray *)uris resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject) {
  resolve([NSNull null]);
}

// Thanks to this guard, we won't compile this code when we build for the old architecture.
#ifdef RCT_NEW_ARCH_ENABLED

- (void)saveDocument:(NSDictionary *)options resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject {
  // not needed on iOS
}

- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:
(const facebook::react::ObjCTurboModule::InitParams &)params {
  return std::make_shared<facebook::react::NativeDocumentPickerSpecJSI>(params);
}

#endif

@end
